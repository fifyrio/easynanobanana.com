
import { saveKIETaskMetadata } from './r2';
import { IMAGE_GENERATION_BASE64_PROMPT, IMAGE_GENERATION_BASE64_TOP_ONLY_PROMPT, EXTRACT_CLOTHING_PROMPT, EXTRACT_CLOTHING_UNZIP_PROMPT, EXTRACT_CLOTHING_TOP_ONLY_PROMPT, EXTRACT_CLOTHING_WITH_MATCH_PROMPT, EXTRACT_CLOTHING_WITH_SHIRT_PROMPT, OUTFIT_CHANGE_V2_PROMPT } from './prompts';

// å›¾ç‰‡ç”Ÿæˆç»“æœ
interface ImageGenerationResult {
    prompt: string;
    imageUrl: string;
    success: boolean;
    timestamp: Date;
    result?: string;
    error?: string;
    savedPath?: string;
    decodedImage?: {
        mimeType: string;
        buffer: Buffer;
        size: number;
    };
}


// KIE API å“åº”ç±»å‹
interface KIECreateTaskResponse {
    code: number;
    message: string;
    data: {
        taskId: string;
    };
}

// KIE å›è°ƒå“åº”ç±»å‹
export interface KIECallbackResponse {
    code: number;
    data: {
        completeTime: number;
        consumeCredits: number;
        costTime: number;
        createTime: number;
        model: string;
        param: string;
        remainedCredits: number;
        resultJson: string;
        state: 'success' | 'failed';
        taskId: string;
        updateTime: number;
    };
    msg: string;
}

// è§£æåçš„ç»“æœ
interface KIEResultJson {
    resultUrls: string[];
}

// ä»»åŠ¡çŠ¶æ€ç±»å‹
export type KIETaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'timeout';

// ä»»åŠ¡å…ƒæ•°æ®ï¼ˆå­˜å‚¨åœ¨ R2ï¼‰
export interface KIETaskMetadata {
    taskId: string;
    status: KIETaskStatus;
    prompt: string;
    imageUrl: string;
    character?: string;
    clothingImageUrl?: string; // ç”¨äº outfit-change-v2ï¼Œå­˜å‚¨æœè£…å›¾ç‰‡URL
    createdAt: string;
    updatedAt: string;
    resultUrls?: string[];
    error?: string;
    consumeCredits?: number;
    costTime?: number;
}

// KIE å›¾ç‰‡ç”ŸæˆæœåŠ¡ç±»
export class KIEImageService {
    private apiToken: string;
    private baseUrl: string;
    private callbackUrl: string;

    constructor() {
        // ä»ç¯å¢ƒå˜é‡è·å–é…ç½®
        this.apiToken = process.env.KIE_API_TOKEN || '';
        this.baseUrl = 'https://api.kie.ai/api/v1/jobs';
        this.callbackUrl = process.env.KIE_CALLBACK_URL || '';

        if (!this.apiToken) {
            console.warn('âš ï¸  KIE_API_TOKEN not configured');
        }

        if (!this.callbackUrl) {
            console.warn('âš ï¸  KIE_CALLBACK_URL not configured');
        }
    }

    /**
     * åˆ›å»º KIE å›¾ç‰‡ç”Ÿæˆä»»åŠ¡
     * @param prompt ç”Ÿæˆæç¤ºè¯
     * @param imageUrls å‚è€ƒå›¾ç‰‡URLï¼ˆå•ä¸ªæˆ–å¤šä¸ªï¼‰
     * @returns ä»»åŠ¡ID
     */
    async createTask(
        prompt: string,
        imageUrls: string | string[],
        imageRatio: '9:16' | '1:1' = '9:16',
        model: string = 'google/nano-banana-edit'
    ): Promise<string> {
        // ç»Ÿä¸€è½¬æ¢ä¸ºæ•°ç»„
        const urls = Array.isArray(imageUrls) ? imageUrls : [imageUrls];

        try {
            console.log(`ğŸ”„ Creating KIE task...`);
            console.log(`ğŸ“ API URL: ${this.baseUrl}/createTask`);
            console.log(`ğŸ“ Prompt length: ${prompt.length} chars`);
            console.log(`ğŸ–¼ï¸  Image URLs: ${urls.length} image(s)`);
            urls.forEach((url, index) => {
                console.log(`   Image ${index + 1}: ${url}`);
            });
            console.log(`ğŸ¤– Model: ${model}`);
            console.log(`ğŸ”‘ Token configured: ${this.apiToken ? 'Yes' : 'No'}`);
            console.log(`ğŸ”— Callback URL: ${this.callbackUrl || 'Not configured'}`);

            const requestBody = {
                model,
                callBackUrl: this.callbackUrl,
                input: {
                    prompt: prompt,
                    image_urls: urls,
                    output_format: 'png',
                    image_size: imageRatio
                }
            };

            console.log(`ğŸ“¤ Request body:`, JSON.stringify(requestBody, null, 2));

            const response = await fetch(`${this.baseUrl}/createTask`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiToken}`
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`âŒ KIE API HTTP error: ${response.status} ${response.statusText}`);
                console.error(`âŒ Response body: ${errorText}`);
                throw new Error(`KIE API request failed: ${response.status} ${errorText}`);
            }

            const responseText = await response.text();
            console.log(`ğŸ“¦ KIE API Response: ${responseText}`);

            let result: KIECreateTaskResponse;
            try {
                result = JSON.parse(responseText);
            } catch (parseError) {
                console.error(`âŒ Failed to parse KIE API response as JSON`);
                console.error(`âŒ Response text: ${responseText}`);
                throw new Error(`KIE API returned invalid JSON: ${responseText.substring(0, 200)}`);
            }

            if (result.code !== 200) {
                console.error(`âŒ KIE API error code: ${result.code}`);
                console.error(`âŒ KIE API error message: ${result.message || 'No error message provided'}`);
                console.error(`âŒ Full response:`, JSON.stringify(result, null, 2));
                const errorMsg = result.message || `Unknown error (code: ${result.code})`;
                throw new Error(`KIE API error: ${errorMsg}`);
            }

            console.log(`âœ… KIE task created: ${result.data.taskId}`);
            return result.data.taskId;
        } catch (error) {
            // æ•è·ç½‘ç»œå±‚é¢çš„é”™è¯¯ï¼ˆå¦‚DNSè§£æå¤±è´¥ã€è¿æ¥è¶…æ—¶ç­‰ï¼‰
            if (error instanceof Error) {
                console.error(`âŒ Network/Fetch error: ${error.message}`);
                console.error(`âŒ Error name: ${error.name}`);
                console.error(`âŒ Error stack: ${error.stack}`);

                // æ£€æŸ¥æ˜¯å¦æ˜¯ç½‘ç»œè¿æ¥é—®é¢˜
                if (error.message === 'fetch failed' || error.name === 'FetchError') {
                    throw new Error(`Network connection failed. Please check: 1) Internet connectivity, 2) KIE API URL (${this.baseUrl}), 3) Firewall/proxy settings. Original error: ${error.message}`);
                }
            }
            throw error;
        }
    }

    /**
     * åˆ›å»ºä»…åŸºäºæ–‡æœ¬æç¤ºè¯çš„ KIE ä»»åŠ¡
     * @param prompt ç”Ÿæˆæç¤ºè¯
     * @param imageRatio å›¾ç‰‡é•¿å®½æ¯”
     * @param model ä½¿ç”¨çš„æ¨¡å‹
     */
    async createPromptOnlyTask(
        prompt: string,
        imageRatio: '9:16' | '1:1' = '9:16',
        model: string = 'google/nano-banana'
    ): Promise<string> {
        try {
            console.log(`ğŸ”„ Creating prompt-only KIE task...`);
            console.log(`ğŸ“ API URL: ${this.baseUrl}/createTask`);
            console.log(`ğŸ“ Prompt length: ${prompt.length} chars`);
            console.log(`ğŸ¤– Model: ${model}`);
            console.log(`ğŸï¸  Image size: ${imageRatio}`);

            const response = await fetch(`${this.baseUrl}/createTask`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiToken}`
                },
                body: JSON.stringify({
                    model,
                    callBackUrl: this.callbackUrl,
                    input: {
                        prompt,
                        output_format: 'png',
                        image_size: imageRatio
                    }
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`âŒ KIE prompt-only HTTP error: ${response.status} ${response.statusText}`);
                console.error(`âŒ Response body: ${errorText}`);
                throw new Error(`KIE API request failed: ${response.status} ${errorText}`);
            }

            const responseText = await response.text();
            console.log(`ğŸ“¦ KIE prompt-only API Response: ${responseText}`);

            let result: KIECreateTaskResponse;
            try {
                result = JSON.parse(responseText);
            } catch (parseError) {
                console.error(`âŒ Failed to parse KIE prompt-only API response as JSON`);
                console.error(`âŒ Response text: ${responseText}`);
                throw new Error(`KIE API returned invalid JSON: ${responseText.substring(0, 200)}`);
            }

            if (result.code !== 200) {
                console.error(`âŒ KIE prompt-only API error code: ${result.code}`);
                console.error(`âŒ KIE prompt-only API error message: ${result.message || 'No error message provided'}`);
                console.error(`âŒ Full response:`, JSON.stringify(result, null, 2));
                const errorMsg = result.message || `Unknown error (code: ${result.code})`;
                throw new Error(`KIE API error: ${errorMsg}`);
            }

            console.log(`âœ… KIE prompt-only task created: ${result.data.taskId}`);
            return result.data.taskId;
        } catch (error) {
            if (error instanceof Error) {
                console.error(`âŒ Prompt-only task error: ${error.message}`);
                if (error.stack) {
                    console.error(error.stack);
                }
            }
            throw error;
        }
    }

    /**
     * é’ˆå¯¹ nano-banana-pro çš„ä¸“ç”¨åˆ›å»ºä»»åŠ¡æ–¹æ³•
     * è¯¥æ¨¡å‹è¦æ±‚ä¸åŒçš„å‚æ•°ç»“æ„
     */
    async createProTask(
        prompt: string,
        imageInputs: string | string[],
        aspectRatio: '9:16' | '1:1' = '9:16',
        resolution: '1K' | '2K' = '2K'
    ): Promise<string> {
        const urls = Array.isArray(imageInputs) ? imageInputs : [imageInputs];

        try {
            console.log(`ğŸ”„ Creating KIE PRO task...`);
            console.log(`ğŸ“ API URL: ${this.baseUrl}/createTask`);
            console.log(`ğŸ“ Prompt length: ${prompt.length} chars`);
            console.log(`ğŸ–¼ï¸  Image inputs: ${urls.length} image(s)`);
            urls.forEach((url, index) => {
                console.log(`   Image ${index + 1}: ${url}`);
            });
            console.log(`ğŸï¸  Aspect Ratio: ${aspectRatio}`);
            console.log(`ğŸ–¥ï¸  Resolution: ${resolution}`);
            console.log(`ğŸ”‘ Token configured: ${this.apiToken ? 'Yes' : 'No'}`);
            console.log(`ğŸ”— Callback URL: ${this.callbackUrl || 'Not configured'}`);

            const requestBody = {
                model: 'nano-banana-pro',
                callBackUrl: this.callbackUrl,
                input: {
                    prompt,
                    image_input: urls,
                    aspect_ratio: aspectRatio,
                    resolution,
                    output_format: 'png'
                }
            };

            console.log(`ğŸ“¤ PRO Request body:`, JSON.stringify(requestBody, null, 2));

            const response = await fetch(`${this.baseUrl}/createTask`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiToken}`
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`âŒ KIE PRO API HTTP error: ${response.status} ${response.statusText}`);
                console.error(`âŒ Response body: ${errorText}`);
                throw new Error(`KIE PRO API request failed: ${response.status} ${errorText}`);
            }

            const responseText = await response.text();
            console.log(`ğŸ“¦ KIE PRO API Response: ${responseText}`);

            let result: KIECreateTaskResponse;
            try {
                result = JSON.parse(responseText);
            } catch (parseError) {
                console.error(`âŒ Failed to parse KIE PRO API response as JSON`);
                console.error(`âŒ Response text: ${responseText}`);
                throw new Error(`KIE PRO API returned invalid JSON: ${responseText.substring(0, 200)}`);
            }

            if (result.code !== 200) {
                console.error(`âŒ KIE PRO API error code: ${result.code}`);
                console.error(`âŒ KIE PRO API error message: ${result.message || 'No error message provided'}`);
                console.error(`âŒ Full response:`, JSON.stringify(result, null, 2));
                const errorMsg = result.message || `Unknown error (code: ${result.code})`;
                throw new Error(`KIE PRO API error: ${errorMsg}`);
            }

            console.log(`âœ… KIE PRO task created: ${result.data.taskId}`);
            return result.data.taskId;
        } catch (error) {
            if (error instanceof Error) {
                console.error(`âŒ KIE PRO error: ${error.message}`);
                if (error.stack) {
                    console.error(error.stack);
                }
            }
            throw error;
        }
    }

    /**
     * æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
     * @param taskId ä»»åŠ¡ID
     * @returns ä»»åŠ¡è¯¦æƒ…
     */
    async getTaskStatus(taskId: string): Promise<KIECallbackResponse['data']> {
        const response = await fetch(`${this.baseUrl}/getTask?taskId=${taskId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.apiToken}`
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`KIE API request failed: ${response.status} ${errorText}`);
        }

        const result: KIECallbackResponse = await response.json();

        if (result.code !== 200) {
            throw new Error(`KIE API error: ${result.msg}`);
        }

        return result.data;
    }

    /**
     * è½®è¯¢ç­‰å¾…ä»»åŠ¡å®Œæˆ
     * @param taskId ä»»åŠ¡ID
     * @param maxAttempts æœ€å¤§è½®è¯¢æ¬¡æ•°ï¼ˆé»˜è®¤30æ¬¡ï¼‰
     * @param intervalMs è½®è¯¢é—´éš”ï¼ˆé»˜è®¤2ç§’ï¼‰
     * @returns ç”Ÿæˆçš„å›¾ç‰‡URL
     */
    async waitForTaskCompletion(
        taskId: string,
        maxAttempts: number = 30,
        intervalMs: number = 2000
    ): Promise<string> {
        for (let i = 0; i < maxAttempts; i++) {
            const status = await this.getTaskStatus(taskId);

            if (status.state === 'success') {
                const resultJson: KIEResultJson = JSON.parse(status.resultJson);
                if (resultJson.resultUrls && resultJson.resultUrls.length > 0) {
                    console.log(`âœ… KIE task completed: ${taskId}`);
                    return resultJson.resultUrls[0];
                }
                throw new Error('KIE task completed but no result URLs found');
            }

            if (status.state === 'failed') {
                throw new Error(`KIE task failed: ${taskId}`);
            }

            // ä»»åŠ¡è¿˜åœ¨è¿›è¡Œä¸­ï¼Œç­‰å¾…åé‡è¯•
            console.log(`â³ KIE task ${taskId} still processing (attempt ${i + 1}/${maxAttempts})...`);
            await new Promise(resolve => setTimeout(resolve, intervalMs));
        }

        throw new Error(`KIE task timeout: ${taskId} (max attempts: ${maxAttempts})`);
    }

    /**
     * ç”Ÿæˆå›¾ç‰‡æ¥å£ï¼ˆå¼‚æ­¥æ¨¡å¼ï¼‰
     * åªåˆ›å»ºä»»åŠ¡å¹¶è¿”å› taskIdï¼Œä¸ç­‰å¾…å®Œæˆ
     * @param clothing æœè£…æè¿°/æç¤ºè¯
     * @param imageUrl å‚è€ƒå›¾ç‰‡URL
     * @param extractTopOnly æ˜¯å¦åªæå–ä¸Šè£…
     * @param wearMask æ˜¯å¦ä½©æˆ´ç™½è‰²å£ç½©
     * @returns åŒ…å« taskId çš„ç”Ÿæˆç»“æœ
     */
    async generateImageBase64(
        clothing: string,
        imageUrl: string,
        extractTopOnly: boolean = false,
        wearMask: boolean = false
    ): Promise<ImageGenerationResult & { taskId?: string }> {
        const startTime = new Date();

        try {
            console.log('ğŸš€ Starting KIE image generation (async)...');
            console.log(`ğŸ“ Prompt: ${clothing}`);
            console.log(`ğŸ–¼ï¸  Image URL: ${imageUrl}`);
            console.log(`ğŸ‘• Extract Top Only: ${extractTopOnly}`);
            console.log(`ğŸ˜· Wear Mask: ${wearMask}`);

            // æ ¹æ® extractTopOnly é€‰æ‹©ä¸åŒçš„ prompt
            const basePrompt = extractTopOnly
                ? IMAGE_GENERATION_BASE64_TOP_ONLY_PROMPT
                : IMAGE_GENERATION_BASE64_PROMPT;

            // å¦‚æœéœ€è¦æˆ´å£ç½©ï¼Œåœ¨æœè£…æè¿°åæ·»åŠ å£ç½©è¦æ±‚
            const clothingWithMask = wearMask
                ? `${clothing}\n\nç‰¹åˆ«è¦æ±‚ï¼šæ¨¡ç‰¹ä½©æˆ´ç™½è‰²å£ç½©ã€‚`
                : clothing;

            const fullPrompt = `${basePrompt}${clothingWithMask}`;
            const taskId = await this.createTask(fullPrompt, imageUrl);
            console.log(`âœ… prompts: ${fullPrompt}`);

            console.log(`âœ… KIE task created: ${taskId}`);

            // ä¿å­˜ä»»åŠ¡å…ƒæ•°æ®åˆ° R2
            const metadata: KIETaskMetadata = {
                taskId,
                status: 'pending',
                prompt: clothing,
                imageUrl,
                createdAt: startTime.toISOString(),
                updatedAt: startTime.toISOString(),
            };

            await saveKIETaskMetadata(metadata);

            // è¿”å› taskIdï¼Œä¸ç­‰å¾…å®Œæˆ
            return {
                prompt: clothing,
                imageUrl,
                success: true,
                timestamp: startTime,
                taskId: taskId,
                result: undefined // å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œresult é€šè¿‡ callback è·å–
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`âŒ KIE task creation failed: ${errorMessage}`);

            return {
                prompt: clothing,
                imageUrl,
                success: false,
                error: errorMessage,
                timestamp: startTime
            };
        }
    }

    /**
     * ç”Ÿæˆæ¨¡ç‰¹å§¿åŠ¿å›¾ç‰‡ï¼ˆå¼‚æ­¥æ¨¡å¼ï¼‰
     * @param pose å§¿åŠ¿æè¿°
     * @param description æœè£…å’Œåœºæ™¯æè¿°
     * @param imageUrl åŸå§‹å›¾ç‰‡URL
     * @param holdingPhone æ˜¯å¦ä¸€åªæ‰‹ä¸¾ç€æ‰‹æœº
     * @param wearingMask æ˜¯å¦å¸¦ç€ç™½è‰²å£ç½©
     * @param useProModel æ˜¯å¦ä½¿ç”¨PROæ¨¡å‹
     * @returns åŒ…å« taskId çš„ç”Ÿæˆç»“æœ
     */
    async generateModelPose(
        pose: string,
        description: string,
        imageUrl: string,
        holdingPhone: boolean = false,
        wearingMask: boolean = false,
        useProModel: boolean = false
    ): Promise<ImageGenerationResult & { taskId?: string }> {
        const startTime = new Date();

        try {
            console.log('ğŸ’ƒ Starting KIE model pose generation (async)...');
            console.log(`ğŸ“ Pose: ${pose}`);
            console.log(`ğŸ“ Description: ${description}`);
            console.log(`ğŸ“± Holding Phone: ${holdingPhone}`);
            console.log(`ğŸ˜· Wearing Mask: ${wearingMask}`);
            console.log(`ğŸš€ Use Pro Model: ${useProModel}`);
            console.log(`ğŸ–¼ï¸  Image URL: ${imageUrl}`);
            if (wearingMask) {
                console.log(`ğŸ˜· Mask Reference: https://png.pngtree.com/png-clipart/20200826/ourmid/pngtree-3d-stereo-white-medical-mask-element-png-image_2332283.jpg`);
            }

            // æ„å»ºæç¤ºè¯
            let poseWithExtras = pose;
            // å¦‚æœæˆ´å£ç½©ï¼Œåˆ™ä¸æ·»åŠ ä¸¾æ‰‹æœºçš„æè¿°
            if (holdingPhone && !wearingMask) {
                poseWithExtras = `${poseWithExtras}ï¼Œæ¨¡ç‰¹ä¸€åªæ‰‹ä¸¾ç€æ‰‹æœº`;
            }

            // å£ç½©æè¿° - ç®€åŒ–ï¼Œä¾èµ–å‚è€ƒå›¾ç‰‡
            let maskRequirement = '';
            if (wearingMask) {
                maskRequirement = `

ğŸ­ ã€å£ç½©è¦æ±‚ - æœ€é«˜ä¼˜å…ˆçº§ã€‘ï¼š
æ¨¡ç‰¹å¿…é¡»ä½©æˆ´å£ç½©ï¼Œå£ç½©æ ·å¼ä¸¥æ ¼å‚è€ƒç¬¬äºŒå¼ è¾“å…¥å›¾ç‰‡ï¼ˆå£ç½©å‚è€ƒå›¾ï¼‰ï¼š
- ğŸ“¸ **å®Œå…¨æŒ‰ç…§å‚è€ƒå›¾ç‰‡ä¸­çš„å£ç½©æ ·å¼ç”Ÿæˆ**
- âœ… æ‰€æœ‰å›¾ç‰‡ä¸­çš„å£ç½©å¿…é¡»ä¿æŒå®Œå…¨ä¸€è‡´çš„æ ·å¼ã€é¢œè‰²ã€å½¢çŠ¶
- âœ… å£ç½©è¦æ­£ç¡®è§„èŒƒä½©æˆ´ï¼Œå®Œå…¨è¦†ç›–å£é¼»`;

                poseWithExtras = `${poseWithExtras}ï¼Œä½©æˆ´å£ç½©ï¼ˆæ ·å¼å‚è€ƒç¬¬äºŒå¼ å›¾ç‰‡ï¼‰`;
            }

            const prompt = `${maskRequirement}

ä¿æŒå›¾ç‰‡ä¸­çš„æœè£…æ ·å¼å’ŒèƒŒæ™¯ç¯å¢ƒå®Œå…¨ä¸å˜ï¼ˆ${description}ï¼‰ï¼Œåªæ”¹å˜æ¨¡ç‰¹çš„å§¿åŠ¿:
å§¿åŠ¿ï¼š${poseWithExtras}

âš ï¸ **æœ€é‡è¦çš„æ ¸å¿ƒè¦æ±‚ - ä¸¥æ ¼ä¿æŒæ¨¡ç‰¹èº«æ**ï¼š
1. **çœ¼ç¥å’Œé¢éƒ¨æœå‘ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰**ï¼š
   - â—â—â—**æ¨¡ç‰¹çš„åŒçœ¼å¿…é¡»æ­£å¸¸å¯¹é½ï¼Œç»å¯¹ä¸èƒ½å‡ºç°æ–—é¸¡çœ¼ï¼ˆå¯¹çœ¼ï¼‰æˆ–æ–œè§†** - è¿™æ˜¯æœ€ä¸¥é‡çš„é”™è¯¯
   - â—â—â—**ä¸¤åªçœ¼ç›çš„ç³å­”å¿…é¡»å¹³è¡Œï¼Œæœå‘åŒä¸€æ–¹å‘** - ä¸èƒ½ä¸€åªçœ¼çœ‹å·¦ä¸€åªçœ¼çœ‹å³ï¼Œä¸èƒ½çœ¼ç æœå†…æˆ–æœå¤–åæ–œ
   - â—**æ¨¡ç‰¹çš„çœ¼ç¥å¿…é¡»çœ‹ç€é•œå¤´æˆ–ç•¥å¾®åå‘ä¸€ä¾§**ï¼ŒåŒçœ¼ä¿æŒå¯¹ç§°å’Œè°
   - â—**ç»å¯¹ä¸è¦è®©æ¨¡ç‰¹çš„çœ¼ç¥æœåœ°ä¸Šçœ‹ã€æœä¸‹çœ‹**
   - â—**é¢éƒ¨æœå‘åº”è¯¥æ˜¯æ­£å¯¹é•œå¤´æˆ–å¾®å¾®ä¾§å‘ï¼Œä½†ä¸è¦ä½å¤´çœ‹åœ°é¢**
   - â—**ä¿æŒä¸“ä¸šæ¨¡ç‰¹çš„é•œå¤´æ„Ÿï¼Œçœ¼ç¥è¦æœ‰ç¥ã€è‡ªä¿¡ã€è‡ªç„¶ï¼Œä¸¤çœ¼æ­£å¸¸å¯¹é½**
   - â—**å³ä½¿æ˜¯ä½å¤´æˆ–ä¾§èº«çš„å§¿åŠ¿ï¼Œçœ¼ç¥ä¹Ÿåº”è¯¥çœ‹å‘é•œå¤´æ–¹å‘ï¼Œè€Œä¸æ˜¯çœ‹åœ°é¢ï¼Œä¸”åŒçœ¼å¿…é¡»å¯¹ç§°å¹³è¡Œ**
2. **ç»å¯¹ä¸è¦æ”¹å˜æ¨¡ç‰¹çš„èº«ææ¯”ä¾‹** - æ¨¡ç‰¹çš„èº«æå¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´ï¼š
   - â—**è‡€éƒ¨å¤§å°å’Œå½¢çŠ¶ç»å¯¹ä¸èƒ½æ”¹å˜** - è¿™æ˜¯æœ€é‡è¦çš„è¦æ±‚ä¹‹ä¸€ï¼š
     * è‡€éƒ¨çš„å¤§å°ï¼ˆè‡€å›´ï¼‰å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´ï¼Œä¸èƒ½å˜å¤§ä¹Ÿä¸èƒ½å˜å°
     * è‡€éƒ¨çš„å½¢çŠ¶å’Œæ›²çº¿å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´
     * è‡€éƒ¨çš„é«˜åº¦å’Œä½ç½®å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´
     * **ç‰¹åˆ«æ˜¯åœ¨ç”ŸæˆèƒŒé¢å§¿åŠ¿æ—¶ï¼Œè‡€éƒ¨çš„æ‰€æœ‰ç‰¹å¾éƒ½å¿…é¡»100%ä¿æŒåŸå›¾**
     * ä¸è¦å› ä¸ºè§’åº¦å˜åŒ–è€Œ"ä¼˜åŒ–"æˆ–"ç¾åŒ–"è‡€éƒ¨
   - â—**è…¿éƒ¨é•¿åº¦ç»å¯¹ä¸èƒ½æ”¹å˜** - è…¿çš„é•¿åº¦ã€ä¸Šä¸‹èº«æ¯”ä¾‹å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´
   - â—**è…¿éƒ¨ç²—ç»†ç»å¯¹ä¸èƒ½æ”¹å˜** - å¤§è…¿ç²—ç»†ã€å°è…¿ç²—ç»†ã€è†ç›–ä½ç½®ã€è„šè¸ç²—ç»†éƒ½ä¸èƒ½æœ‰ä»»ä½•å˜åŒ–
   - â—**è…¿éƒ¨å½¢çŠ¶å®Œå…¨ä¿ç•™** - è…¿çš„å½¢çŠ¶ã€çº¿æ¡ã€æ›²çº¿å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´
   - â—**èº«ä½“å…¶ä»–éƒ¨ä½ä¹Ÿè¦ä¿æŒ** - èƒ¸éƒ¨å¤§å°ã€è…°å›´ã€è‚©å®½ã€æ‰‹è‡‚ç²—ç»†ç­‰æ‰€æœ‰èº«æç‰¹å¾éƒ½ä¸èƒ½æ”¹å˜
   - â—**æ•´ä½“èº«ææ›²çº¿å®Œå…¨ä¿ç•™** - æ‰€æœ‰èº«ä½“å°ºå¯¸å’Œæ¯”ä¾‹ä¿æŒä¸å˜
2. **å®Œå…¨ä¿æŒåŸèƒŒæ™¯ä¸å˜** - èƒŒæ™¯ç¯å¢ƒã€åœºæ™¯ã€é“å…·ã€å…‰çº¿ç­‰å®Œå…¨ä¸åŸå›¾ä¸€è‡´
3. **å®Œå…¨ä¿æŒæœè£…ä¸å˜** - æœè£…æ¬¾å¼ã€é¢œè‰²ã€æè´¨ã€ç»†èŠ‚ä¸åŸå›¾å®Œå…¨ä¸€è‡´
4. **åªæ”¹å˜æ¨¡ç‰¹å§¿åŠ¿** - æŒ‰ç…§å§¿åŠ¿æè¿°è¦æ±‚æ”¹å˜æ¨¡ç‰¹çš„åŠ¨ä½œã€è§’åº¦ã€è¡¨æƒ…
5. **ä¿æŒæ•´ä½“åè°ƒ** - æ–°å§¿åŠ¿è¦ä¸èƒŒæ™¯å’Œæœè£…é£æ ¼åè°ƒè‡ªç„¶

å§¿åŠ¿ç¾å­¦è¦æ±‚ï¼ˆåœ¨ä¸æ”¹å˜èº«æçš„å‰æä¸‹ï¼‰ï¼š
1. **è…¿éƒ¨åŠ¨ä½œè¦è‡ªç„¶æŸ”ç¾** - é¿å…åŒè…¿ç¬”ç›´åƒµç¡¬åœ°ç«™ç«‹ï¼š
   - âš ï¸ æ³¨æ„ï¼šæ”¹å˜å§¿åŠ¿æ—¶ï¼Œè…¿çš„ç²—ç»†ã€é•¿çŸ­å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´ï¼Œåªæ”¹å˜è…¿çš„æ‘†æ”¾è§’åº¦å’Œå§¿æ€
   - ä¸€æ¡è…¿å¯ä»¥å¾®å¾®å¼¯æ›²ï¼Œå‘ˆç°æ”¾æ¾è‡ªç„¶çš„çŠ¶æ€
   - é‡å¿ƒå¯ä»¥åå‘ä¸€ä¾§ï¼Œå¦ä¸€è…¿è½»è½»ç‚¹åœ°æˆ–äº¤å‰
   - è†ç›–å¾®å±ˆï¼Œå±•ç°ä¼˜é›…çš„Så‹æ›²çº¿
   - è„šè¸å¯ä»¥æœ‰è½»å¾®è§’åº¦å˜åŒ–ï¼Œé¿å…åƒµç›´
   - åŒè…¿ä¹‹é—´ä¿æŒé€‚åº¦ç©ºé—´ï¼Œé¿å…å®Œå…¨å¹¶æ‹¢çš„åƒµç¡¬æ„Ÿ
2. **èº«ä½“å§¿æ€æµç•…** - å±•ç°ä¸“ä¸šæ¨¡ç‰¹çš„ä¼˜é›…æ°”è´¨ï¼š
   - èº«ä½“å¯ä»¥æœ‰è½»å¾®çš„ä¾§è½¬æˆ–å€¾æ–œ
   - è‚©è†€æ”¾æ¾ï¼Œä¸è¦è¿‡äºç´§ç»·
   - è…°éƒ¨å’Œèƒ¯éƒ¨å‘ˆç°è‡ªç„¶çš„æ›²çº¿ç¾
   - æ•´ä½“å§¿æ€å‘ˆç°æŸ”å’Œçš„æµçº¿å‹
3. **åŠ¨ä½œåè°ƒæ€§** - æ‰‹éƒ¨ã€è…¿éƒ¨ã€èº«ä½“åŠ¨ä½œè¦äº’ç›¸å‘¼åº”ï¼Œå½¢æˆå’Œè°çš„æ•´ä½“é€ å‹

âŒ ç»å¯¹ç¦æ­¢çš„æ“ä½œï¼š
- âŒâŒâŒ **ç»å¯¹ä¸èƒ½ç”Ÿæˆæ–—é¸¡çœ¼ï¼ˆå¯¹çœ¼ï¼‰æˆ–æ–œè§†** - è¿™æ˜¯æœ€ä¸¥é‡çš„é”™è¯¯ï¼Œå¿…é¡»é¿å…
- âŒâŒâŒ **ä¸èƒ½è®©ä¸¤åªçœ¼ç›çš„ç³å­”æ–¹å‘ä¸ä¸€è‡´** - åŒçœ¼å¿…é¡»å¹³è¡Œå¯¹é½ï¼Œæœå‘åŒä¸€æ–¹å‘
- âŒâŒâŒ **ä¸è¦è®©æ¨¡ç‰¹çœ¼ç¥æœåœ°ä¸Šçœ‹ã€æœä¸‹çœ‹** - è¿™æ˜¯æœ€å¸¸è§çš„é”™è¯¯ï¼Œå¿…é¡»é¿å…
- âŒâŒâŒ **ä¸è¦è®©æ¨¡ç‰¹ä½å¤´çœ‹åœ°é¢** - å³ä½¿æ˜¯ä½å¤´åŠ¨ä½œï¼Œçœ¼ç¥ä¹Ÿåº”è¯¥çœ‹å‘é•œå¤´æ–¹å‘
- âŒ ä¸è¦æ”¹å˜è‡€éƒ¨çš„å¤§å°ï¼ˆä¸èƒ½è®©è‡€éƒ¨å˜å¤§æˆ–å˜å°ï¼‰
- âŒ ä¸è¦æ”¹å˜è‡€éƒ¨çš„å½¢çŠ¶ï¼ˆä¸èƒ½æ”¹å˜è‡€éƒ¨æ›²çº¿å’Œè½®å»“ï¼‰
- âŒ **ç‰¹åˆ«ç¦æ­¢ï¼šåœ¨ç”ŸæˆèƒŒé¢å§¿åŠ¿æ—¶æ”¹å˜è‡€éƒ¨å¤§å°** - èƒŒé¢å›¾ç‰‡æ—¶è‡€éƒ¨æœ€æ˜æ˜¾ï¼Œå¿…é¡»ä¸¥æ ¼ä¿æŒåŸå›¾è‡€éƒ¨ç‰¹å¾
- âŒ ä¸è¦æ”¹å˜è…¿çš„é•¿åº¦ï¼ˆä¸èƒ½æ‹‰é•¿æˆ–ç¼©çŸ­è…¿ï¼‰
- âŒ ä¸è¦æ”¹å˜è…¿çš„ç²—ç»†ï¼ˆä¸èƒ½è®©è…¿å˜ç»†æˆ–å˜ç²—ï¼‰
- âŒ ä¸è¦æ”¹å˜è…¿çš„å½¢çŠ¶ï¼ˆä¸èƒ½æ”¹å˜è…¿éƒ¨çº¿æ¡å’Œæ›²çº¿ï¼‰
- âŒ ä¸è¦ä¸ºäº†"æ˜¾ç˜¦"ã€"æ˜¾é«˜"ã€"æ‹‰é•¿æ¯”ä¾‹"ã€"æè‡€"ã€"ç¾åŒ–èº«æ"è€Œä¿®æ”¹ä»»ä½•èº«ä½“éƒ¨ä½
- âŒ ä¸è¦æ”¹å˜å…¶ä»–ä»»ä½•èº«ä½“éƒ¨ä½çš„å°ºå¯¸å’Œæ¯”ä¾‹

âœ… æ­£ç¡®åšæ³•ï¼š
- âœ…âœ…âœ… **åŒçœ¼å¿…é¡»æ­£å¸¸å¯¹é½ï¼Œç³å­”å¹³è¡Œï¼Œç»å¯¹ä¸èƒ½æ–—é¸¡çœ¼** - è¿™æ˜¯æœ€åŸºæœ¬çš„è¦æ±‚
- âœ…âœ…âœ… **ä¸¤åªçœ¼ç›æœå‘åŒä¸€æ–¹å‘ï¼Œä¿æŒå¯¹ç§°å’Œè°** - ç¡®ä¿çœ¼ç¥è‡ªç„¶åè°ƒ
- âœ…âœ…âœ… **æ¨¡ç‰¹çœ¼ç¥çœ‹å‘é•œå¤´æˆ–ç•¥å¾®åå‘ä¸€ä¾§** - ä¿æŒä¸“ä¸šæ¨¡ç‰¹çš„é•œå¤´æ„Ÿå’Œè‡ªä¿¡çœ¼ç¥
- âœ…âœ…âœ… **é¢éƒ¨æ­£å¯¹æˆ–ä¾§å‘é•œå¤´** - ä¸è¦ä½å¤´çœ‹åœ°é¢ï¼Œä¿æŒä¸è§‚ä¼—çš„è§†çº¿äº¤æµ
- âœ… åªæ”¹å˜å§¿åŠ¿ï¼ˆèº«ä½“è§’åº¦ã€è…¿çš„æ‘†æ”¾è§’åº¦ã€ç«™å§¿ã€åŠ¨ä½œï¼‰ï¼Œç»å¯¹ä¸æ”¹å˜èº«æï¼ˆè‡€éƒ¨å¤§å°ã€è…¿çš„é•¿çŸ­ã€ç²—ç»†ï¼‰
- âœ… å§¿åŠ¿é€‚åº”åŸæœ‰èº«æï¼Œè€Œä¸æ˜¯èº«æé€‚åº”å§¿åŠ¿
- âœ… ä¿æŒåŸå›¾æ¨¡ç‰¹çœŸå®çš„èº«ææ¯”ä¾‹ï¼Œå±•ç°çœŸå®çš„å§¿æ€æ•ˆæœ
- âœ… **èƒŒé¢å§¿åŠ¿æ—¶ç‰¹åˆ«æ³¨æ„ï¼šè‡€éƒ¨æ˜¯æœ€æ˜¾çœ¼çš„éƒ¨ä½ï¼Œå¿…é¡»100%ä¿æŒåŸå›¾çš„è‡€éƒ¨å¤§å°å’Œå½¢çŠ¶**

è¯·ç”Ÿæˆä¸€å¼ ç¬¦åˆä¸Šè¿°è¦æ±‚çš„æ¨¡ç‰¹å›¾ç‰‡ï¼Œç‰¹åˆ«æ³¨æ„ï¼š
1. **æ¨¡ç‰¹çš„åŒçœ¼å¿…é¡»æ­£å¸¸å¯¹é½ï¼Œç»å¯¹ä¸èƒ½å‡ºç°æ–—é¸¡çœ¼ï¼ˆå¯¹çœ¼ï¼‰æˆ–æ–œè§†ï¼Œä¸¤åªçœ¼ç›çš„ç³å­”å¿…é¡»å¹³è¡Œæœå‘åŒä¸€æ–¹å‘** - è¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§è¦æ±‚
2. **æ¨¡ç‰¹çš„çœ¼ç¥å¿…é¡»çœ‹å‘é•œå¤´æˆ–ç•¥å¾®åå‘ä¸€ä¾§ï¼Œç»å¯¹ä¸è¦æœåœ°ä¸Šçœ‹ã€æœä¸‹çœ‹** - è¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§è¦æ±‚
3. **åœ¨å±•ç°èƒŒé¢å§¿åŠ¿æ—¶ï¼Œè‡€éƒ¨çš„å¤§å°ã€å½¢çŠ¶ã€æ›²çº¿å¿…é¡»ä¸åŸå›¾å®Œå…¨ä¸€è‡´**
4. åœ¨å±•ç°è…¿éƒ¨åŠ¨ä½œè‡ªç„¶ä¼˜é›…çš„åŒæ—¶ï¼Œå¿…é¡»å®Œå…¨ä¿æŒåŸå›¾ä¸­è…¿éƒ¨çš„é•¿åº¦ã€ç²—ç»†å’Œå½¢çŠ¶ä¸å˜
5. æ‰€æœ‰èº«æç‰¹å¾ï¼ˆè‡€éƒ¨ã€è…¿éƒ¨ã€è…°éƒ¨ç­‰ï¼‰éƒ½å¿…é¡»ä¸åŸå›¾100%ä¸€è‡´ï¼Œåªæ”¹å˜å§¿åŠ¿è§’åº¦${wearingMask ? '\n6. **ã€å£ç½©è¦æ±‚å†æ¬¡å¼ºè°ƒã€‘æ¨¡ç‰¹å¿…é¡»ä½©æˆ´å£ç½©ï¼Œå£ç½©æ ·å¼å®Œå…¨æŒ‰ç…§ç¬¬äºŒå¼ è¾“å…¥å›¾ç‰‡ï¼ˆå£ç½©å‚è€ƒå›¾ï¼‰ç”Ÿæˆï¼Œæ‰€æœ‰å›¾ç‰‡ä¸­çš„å£ç½©å¿…é¡»ä¿æŒå®Œå…¨ä¸€è‡´**' : ''}`;

            // åˆ›å»ºä»»åŠ¡ï¼ˆæ ¹æ®useProModelé€‰æ‹©ä¸åŒçš„æ–¹æ³•ï¼‰
            // å¦‚æœå¼€å¯å£ç½©åŠŸèƒ½ï¼Œæ·»åŠ å£ç½©å‚è€ƒå›¾ç‰‡
            const maskReferenceUrl = 'https://png.pngtree.com/png-clipart/20200826/ourmid/pngtree-3d-stereo-white-medical-mask-element-png-image_2332283.jpg';
            const imageInputs = wearingMask ? [imageUrl, maskReferenceUrl] : imageUrl;

            const taskId = useProModel
                ? await this.createProTask(prompt, imageInputs, '9:16', '2K')
                : await this.createTask(prompt, imageInputs);
            console.log(`âœ… KIE task created: ${taskId}`);

            // ä¿å­˜ä»»åŠ¡å…ƒæ•°æ®åˆ° R2
            const metadata: KIETaskMetadata = {
                taskId,
                status: 'pending',
                prompt: pose,
                imageUrl,
                createdAt: startTime.toISOString(),
                updatedAt: startTime.toISOString(),
            };

            await saveKIETaskMetadata(metadata);

            // è¿”å› taskIdï¼Œä¸ç­‰å¾…å®Œæˆ
            return {
                prompt: pose,
                imageUrl,
                success: true,
                timestamp: startTime,
                taskId: taskId,
                result: undefined // å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œresult é€šè¿‡ callback è·å–
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`âŒ KIE model pose task creation failed: ${errorMessage}`);

            return {
                prompt: pose,
                imageUrl,
                success: false,
                error: errorMessage,
                timestamp: startTime
            };
        }
    }

    /**
     * æå–æœè£…ï¼ˆå»é™¤æ¨¡ç‰¹ï¼‰
     * @param imageUrl åŸå§‹å›¾ç‰‡URL
     * @param recommendMatch æ˜¯å¦æ¨èæ­é…çš„è£¤å­æˆ–ä¸Šè¡£
     * @param recommendShirt æ˜¯å¦æ¨èæ­é…çš„å†…æ­è¡¬è¡£
     * @param extractTopOnly æ˜¯å¦åªæå–ä¸Šè£…
     * @param unzipJacket æ˜¯å¦å¼ºåˆ¶å¤–å¥—æ•å¼€ï¼ˆä¸æ‹‰æ‹‰é“¾ã€ä¸æ‰£çº½æ‰£ï¼‰
     * @returns åŒ…å« taskId çš„ç”Ÿæˆç»“æœ
     */
    async extractClothing(
        imageUrl: string,
        recommendMatch: boolean = false,
        recommendShirt: boolean = false,
        extractTopOnly: boolean = false,
        unzipJacket: boolean = false
    ): Promise<ImageGenerationResult & { taskId?: string }> {
        const startTime = new Date();

        try {
            console.log('ğŸ‘” Starting KIE clothing extraction (async)...');
            console.log(`ğŸ–¼ï¸  Image URL: ${imageUrl}`);
            console.log(`ğŸ¯ Recommend Match: ${recommendMatch}`);
            console.log(`ğŸ‘” Recommend Shirt: ${recommendShirt}`);
            console.log(`ğŸ‘• Extract Top Only: ${extractTopOnly}`);
            console.log(`ğŸ§¥ Unzip Jacket: ${unzipJacket}`);

            // æ ¹æ® extractTopOnlyã€recommendMatchã€recommendShirt å’Œ unzipJacket é€‰æ‹©ä¸åŒçš„ prompt
            let prompt: string;
            let promptType: string;

            if (extractTopOnly) {
                prompt = EXTRACT_CLOTHING_TOP_ONLY_PROMPT;
                promptType = 'TOP_ONLY';
            } else if (recommendShirt) {
                prompt = EXTRACT_CLOTHING_WITH_SHIRT_PROMPT;
                promptType = 'WITH_SHIRT';
            } else if (recommendMatch) {
                prompt = EXTRACT_CLOTHING_WITH_MATCH_PROMPT;
                promptType = 'WITH_MATCH';
            } else if (unzipJacket) {
                prompt = EXTRACT_CLOTHING_UNZIP_PROMPT;
                promptType = 'UNZIP';
            } else {
                prompt = EXTRACT_CLOTHING_PROMPT;
                promptType = 'STANDARD';
            }

            console.log(`ğŸ“ Using prompt: ${promptType}`);

            // åˆ›å»ºä»»åŠ¡ï¼Œä½¿ç”¨ 1:1 çš„å›¾ç‰‡æ¯”ä¾‹
            const taskId = await this.createTask(prompt, imageUrl, '1:1');
            console.log(`âœ… KIE task created: ${taskId}`);

            // ä¿å­˜ä»»åŠ¡å…ƒæ•°æ®åˆ° R2
            const metadata: KIETaskMetadata = {
                taskId,
                status: 'pending',
                prompt: 'Extract Clothing',
                imageUrl,
                createdAt: startTime.toISOString(),
                updatedAt: startTime.toISOString(),
            };

            await saveKIETaskMetadata(metadata);

            // è¿”å› taskIdï¼Œä¸ç­‰å¾…å®Œæˆ
            return {
                prompt: 'Extract Clothing',
                imageUrl,
                success: true,
                timestamp: startTime,
                taskId: taskId,
                result: undefined // å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œresult é€šè¿‡ callback è·å–
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`âŒ KIE clothing extraction task creation failed: ${errorMessage}`);

            return {
                prompt: 'Extract Clothing',
                imageUrl,
                success: false,
                error: errorMessage,
                timestamp: startTime
            };
        }
    }

    /**
     * æ¨¡ç‰¹æ¢è£…V2ï¼ˆå°†æå–çš„æœè£…ç©¿åˆ°æŒ‡å®šæ¨¡ç‰¹èº«ä¸Šï¼‰
     * @param clothingImageUrl æå–çš„æœè£…å›¾ç‰‡URL
     * @param modelImageUrl æ¨¡ç‰¹å›¾ç‰‡URL
     * @param character æ¨¡ç‰¹è§’è‰²
     * @param adjustPose æ˜¯å¦å¾®è°ƒæ¨¡ç‰¹åŠ¨ä½œ
     * @returns åŒ…å« taskId çš„ç”Ÿæˆç»“æœ
     */
    async outfitChangeV2(
        clothingImageUrl: string,
        modelImageUrl: string,
        character: string,
        adjustPose: boolean = false,
        useProModel: boolean = false,
        wearingMask: boolean = false
    ): Promise<ImageGenerationResult & { taskId?: string }> {
        const startTime = new Date();

        try {
            console.log('ğŸ‘— Starting outfit change V2 (async)...');
            console.log(`ğŸ‘” Clothing URL: ${clothingImageUrl}`);
            console.log(`ğŸ§ Model URL: ${modelImageUrl}`);
            console.log(`ğŸ­ Character: ${character}`);
            console.log(`ğŸ’ƒ Adjust Pose: ${adjustPose}`);
            console.log(`ğŸ§  Use Pro Model: ${useProModel}`);
            console.log(`ğŸ˜· Wearing Mask: ${wearingMask}`);

            // ä½¿ç”¨æ¢è£…V2çš„ prompt
            let prompt = OUTFIT_CHANGE_V2_PROMPT;

            // å¦‚æœå¼€å¯å£ç½©åŠŸèƒ½ï¼Œæ·»åŠ å£ç½©è¦æ±‚åˆ°åŸºç¡€promptï¼ˆæ— è®ºæ˜¯å¦å¼€å¯åŠ¨ä½œå¾®è°ƒï¼‰
            if (wearingMask) {
                prompt = prompt + `\n\nğŸ˜· ã€å£ç½©è¦æ±‚ - æœ€é«˜ä¼˜å…ˆçº§ - è¦†ç›–æ‰€æœ‰å…¶ä»–é¢éƒ¨é…é¥°è§„åˆ™ã€‘ï¼š
âš ï¸ **é‡è¦ï¼šæ— è®ºç¬¬äºŒå¼ å›¾ç‰‡ï¼ˆæ¨¡ç‰¹å›¾ï¼‰ä¸­æ˜¯å¦ä½©æˆ´å£ç½©ï¼Œç”Ÿæˆçš„å›¾ç‰‡ä¸­æ¨¡ç‰¹å¿…é¡»ä½©æˆ´å£ç½©**
âš ï¸ **å£ç½©æ ·å¼ä¸¥æ ¼å‚è€ƒç¬¬ä¸‰å¼ è¾“å…¥å›¾ç‰‡ï¼ˆå£ç½©å‚è€ƒå›¾ï¼‰ï¼Œä¸æ˜¯å‚è€ƒç¬¬äºŒå¼ æ¨¡ç‰¹å›¾**

æ¨¡ç‰¹å¿…é¡»ä½©æˆ´å£ç½©ï¼Œå…·ä½“è¦æ±‚å¦‚ä¸‹ï¼š
- âœ… **å®Œå…¨æŒ‰ç…§ç¬¬ä¸‰å¼ å‚è€ƒå›¾ç‰‡ä¸­çš„å£ç½©æ ·å¼ç”Ÿæˆ**ï¼šåŒ…æ‹¬é¢œè‰²ã€å½¢çŠ¶ã€ç«‹ä½“è¤¶çš±ã€æè´¨ã€é‡‘å±é¼»æ¢æ¡ã€è€³æŒ‚ç»³ç­‰æ‰€æœ‰ç»†èŠ‚å¿…é¡»ä¸ç¬¬ä¸‰å¼ å‚è€ƒå›¾ç‰‡å®Œå…¨ä¸€è‡´
- âœ… **çœŸå®çš„åŒ»ç”¨æ— çººå¸ƒè´¨æ„Ÿ**ï¼šä¾ç…§å‚è€ƒå›¾ç‰‡å±•ç°çœŸå®çš„æè´¨ã€å…‰å½±ã€è¤¶çš±æ·±åº¦
- âœ… **ä½©æˆ´è§„èŒƒ**ï¼šå£ç½©å®Œå…¨è¦†ç›–å£é¼»ï¼Œä¸Šç¼˜è´´åˆé¼»æ¢ï¼Œä¸‹ç¼˜è¦†ç›–ä¸‹å·´ï¼Œç´§è´´é¢éƒ¨æ— ç¼éš™
- âœ… **ä¸€è‡´æ€§**ï¼šæ‰€æœ‰å›¾ç‰‡ä¸­çš„å£ç½©æ ·å¼å¿…é¡»ä¸ç¬¬ä¸‰å¼ å‚è€ƒå›¾ç‰‡ä¿æŒå®Œå…¨ä¸€è‡´
- âœ… **å¼ºåˆ¶è¦æ±‚**ï¼šå³ä½¿ç¬¬äºŒå¼ å›¾ç‰‡çš„æ¨¡ç‰¹æ²¡æœ‰æˆ´å£ç½©ï¼Œç”Ÿæˆçš„å›¾ç‰‡ä¸­ä¹Ÿå¿…é¡»æ·»åŠ å£ç½©`;
            }

            // å¦‚æœå¼€å¯åŠ¨ä½œå¾®è°ƒåˆ™æ·»åŠ ç›¸å…³æç¤º
            if (adjustPose) {
                // ç”Ÿæˆéšæœºçš„å§¿åŠ¿å˜åŒ–é€‰é¡¹ï¼Œå¢åŠ å¤šæ ·æ€§
                const handPoses = [
                    'å³æ‰‹è‡ªç„¶ä¸‹å‚ï¼Œå·¦æ‰‹è½»è½»æ­åœ¨è…°é—´',
                    'åŒæ‰‹è‡ªç„¶å‚æ”¾åœ¨èº«ä½“ä¸¤ä¾§ï¼Œæ‰‹æŒ‡å¾®å¾®å¼ å¼€',
                    'å³æ‰‹æ’å£è¢‹ï¼Œå·¦æ‰‹è‡ªç„¶ä¸‹å‚',
                    'å·¦æ‰‹æ’å£è¢‹ï¼Œå³æ‰‹è‡ªç„¶ä¸‹å‚',
                    'åŒæ‰‹è½»è½»äº¤å‰æ”¾åœ¨èº«å‰',
                    'ä¸€åªæ‰‹è½»æ‰¶å¤´å‘ï¼Œå¦ä¸€åªæ‰‹è‡ªç„¶ä¸‹å‚',
                    'ä¸€åªæ‰‹è½»æ‹‰è¡£è§’ï¼Œå¦ä¸€åªæ‰‹è‡ªç„¶å‚æ”¾',
                    'åŒæ‰‹è½»è½»æ­åœ¨å¤§è…¿ä¸Š',
                    'ä¸€åªæ‰‹å‰è…°ï¼Œå¦ä¸€åªæ‰‹è‡ªç„¶ä¸‹å‚',
                    'åŒæ‰‹è½»æ¡åœ¨èº«å‰'
                ];

                const bodyAngles = [
                    'èº«ä½“æ­£å¯¹é•œå¤´',
                    'èº«ä½“å¾®å¾®å‘å³ä¾§è½¬15åº¦',
                    'èº«ä½“å¾®å¾®å‘å·¦ä¾§è½¬15åº¦',
                    'è‚©è†€å¾®å¾®å€¾æ–œï¼Œå‘ˆç°æ”¾æ¾å§¿æ€',
                    'èº«ä½“ä¿æŒç«¯æ­£ä½†æ”¾æ¾çš„çŠ¶æ€'
                ];

                const legPoses = [
                    'åŒè…¿è‡ªç„¶å¹¶æ‹¢ç«™ç«‹',
                    'å·¦è…¿å¾®å¾®å‘å‰ï¼Œå³è…¿åœ¨åï¼Œé‡å¿ƒåœ¨åè…¿',
                    'å³è…¿å¾®å¾®å‘å‰ï¼Œå·¦è…¿åœ¨åï¼Œé‡å¿ƒåœ¨åè…¿',
                    'åŒè…¿å¾®å¾®åˆ†å¼€ç«™ç«‹ï¼Œé‡å¿ƒå‡åŒ€åˆ†å¸ƒ',
                    'ä¸€æ¡è…¿å¾®å±ˆï¼Œå¦ä¸€æ¡è…¿ä¼¸ç›´ç«™ç«‹',
                    'åŒè…¿è‡ªç„¶äº¤å‰ç«™ç«‹ï¼Œå‘ˆç°ä¼˜é›…å§¿æ€'
                ];

                // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºéšæœºç§å­ï¼Œç¡®ä¿æ¯æ¬¡è°ƒç”¨æœ‰ä¸åŒçš„ç»„åˆ
                const timestamp = Date.now();
                const handIndex = timestamp % handPoses.length;
                const bodyIndex = Math.floor(timestamp / 1000) % bodyAngles.length;
                const legIndex = Math.floor(timestamp / 10000) % legPoses.length;

                const selectedHandPose = handPoses[handIndex];
                const selectedBodyAngle = bodyAngles[bodyIndex];
                const selectedLegPose = legPoses[legIndex];

                console.log(`ğŸ² Random pose selected:`);
                console.log(`  Hand: ${selectedHandPose}`);
                console.log(`  Body: ${selectedBodyAngle}`);
                console.log(`  Legs: ${selectedLegPose}`);

                prompt = prompt + `\n\nâš ï¸ **åŠ¨ä½œå¾®è°ƒè¦æ±‚ - å¿…é¡»ä¸¥æ ¼æ‰§è¡Œä»¥ä¸‹å§¿åŠ¿å˜åŒ–**ï¼š

**ğŸ¯ æ ¸å¿ƒåŸåˆ™ï¼šåœ¨ä¿æŒæ¨¡ç‰¹èº«æã€æœè£…ã€èƒŒæ™¯å®Œå…¨ä¸å˜çš„å‰æä¸‹ï¼Œæ”¹å˜æ¨¡ç‰¹çš„å§¿åŠ¿å’ŒåŠ¨ä½œ**

**ğŸ“ å…·ä½“å§¿åŠ¿è¦æ±‚ï¼ˆå¿…é¡»æŒ‰ç…§ä»¥ä¸‹æè¿°ç”Ÿæˆï¼‰ï¼š**

1. **æ‰‹éƒ¨åŠ¨ä½œ**ï¼š${selectedHandPose}

2. **èº«ä½“è§’åº¦**ï¼š${selectedBodyAngle}

3. **è…¿éƒ¨å§¿åŠ¿**ï¼š${selectedLegPose}
   ï¼ˆâš ï¸ æ³¨æ„ï¼šæ”¹å˜è…¿éƒ¨å§¿åŠ¿æ—¶ï¼Œè…¿çš„é•¿åº¦ã€ç²—ç»†ã€å½¢çŠ¶å¿…é¡»ä¸ç¬¬äºŒå¼ å›¾å®Œå…¨ä¸€è‡´ï¼Œåªæ”¹å˜è…¿çš„æ‘†æ”¾è§’åº¦å’Œç«™å§¿ï¼Œä¸æ”¹å˜è…¿çš„ä»»ä½•èº«æç‰¹å¾ï¼‰

4. **é¢éƒ¨è¡¨æƒ…**ï¼šè‡ªç„¶å¾®ç¬‘æˆ–å¹³é™è¡¨æƒ…ï¼Œçœ¼ç¥çœ‹å‘é•œå¤´æˆ–ç•¥å¾®åå‘ä¸€ä¾§

${wearingMask ? `5. **é¢éƒ¨é…é¥°**ï¼šæ¨¡ç‰¹ä½©æˆ´å£ç½©ï¼ˆå£ç½©æ ·å¼ä¸¥æ ¼å‚è€ƒç¬¬ä¸‰å¼ è¾“å…¥å›¾ç‰‡ï¼‰` : ''}

**âœ… å¿…é¡»åšåˆ°ï¼š**
- ä¸¥æ ¼æŒ‰ç…§ä¸Šè¿°æ‰‹éƒ¨ã€èº«ä½“ã€è…¿éƒ¨çš„å…·ä½“æè¿°ç”Ÿæˆå§¿åŠ¿
- å§¿åŠ¿è¦è‡ªç„¶ã€ä¼˜é›…ã€ç¬¦åˆæ•´ä½“é£æ ¼
- æ•´ä½“å§¿æ€è¦åè°ƒç»Ÿä¸€ï¼Œä¸èƒ½ç”Ÿç¡¬

**âŒ ç»å¯¹ç¦æ­¢ï¼š**
- ä¸è¦ä¿æŒä¸ç¬¬äºŒå¼ å›¾å®Œå…¨ç›¸åŒçš„å§¿åŠ¿ï¼ˆå¿…é¡»æœ‰å˜åŒ–ï¼‰
- ä¸è¦æ”¹å˜æ¨¡ç‰¹çš„ä»»ä½•èº«æç‰¹å¾ï¼ˆèº«é«˜ã€èƒ–ç˜¦ã€è…¿é•¿ã€è…¿ç²—ç»†ã€èƒ¸å›´ã€è…°å›´ç­‰ï¼‰
- ä¸è¦æ”¹å˜æœè£…çš„æ¬¾å¼ã€å°ºå¯¸ã€é¢œè‰²ã€ç»†èŠ‚
- ä¸è¦æ”¹å˜èƒŒæ™¯ç¯å¢ƒ

**ğŸ¯ ç›®æ ‡ï¼šç”Ÿæˆä¸€å¼ æ¨¡ç‰¹ç©¿ç€ç¬¬ä¸€å¼ å›¾æœè£…çš„ç…§ç‰‡ï¼Œå§¿åŠ¿æŒ‰ç…§ä¸Šè¿°å…·ä½“è¦æ±‚æ”¹å˜ï¼Œä½†èº«æã€æœè£…ã€èƒŒæ™¯ä¸é¢„æœŸå®Œå…¨ä¸€è‡´ã€‚**`;
            }

            // å‡†å¤‡å›¾ç‰‡è¾“å…¥æ•°ç»„
            // ç¬¬ä¸€å¼ ï¼šæœè£…å›¾ç‰‡ï¼ˆwhat to wearï¼‰
            // ç¬¬äºŒå¼ ï¼šæ¨¡ç‰¹å›¾ç‰‡ï¼ˆwho will wearï¼‰
            // ç¬¬ä¸‰å¼ ï¼ˆå¯é€‰ï¼‰ï¼šå£ç½©å‚è€ƒå›¾ç‰‡ï¼ˆmask referenceï¼‰
            const maskReferenceUrl = 'https://pub-9e76573778404f65b02c3ea29d2db5f9.r2.dev/mask/white-mask.png';
            const imageInputs = wearingMask
                ? [clothingImageUrl, modelImageUrl, maskReferenceUrl]
                : [clothingImageUrl, modelImageUrl];

            if (wearingMask) {
                console.log(`ğŸ˜· Mask Reference added: ${maskReferenceUrl}`);
            }

            const taskId = useProModel
                ? await this.createProTask(
                    prompt,
                    imageInputs,
                    '9:16',
                    '2K'
                )
                : await this.createTask(
                    prompt,
                    imageInputs,
                    '9:16',
                    'google/nano-banana-edit'
                );

            console.log(`âœ… KIE task created: ${taskId}`);

            // ä¿å­˜ä»»åŠ¡å…ƒæ•°æ®åˆ° R2
            const metadata: KIETaskMetadata = {
                taskId,
                status: 'pending',
                prompt: 'Outfit Change V2',
                imageUrl: modelImageUrl, // ä¿å­˜æ¨¡ç‰¹URLä½œä¸ºä¸»URL
                character,
                clothingImageUrl, // é¢å¤–ä¿å­˜æœè£…URL
                createdAt: startTime.toISOString(),
                updatedAt: startTime.toISOString(),
            };

            await saveKIETaskMetadata(metadata);

            // è¿”å› taskIdï¼Œä¸ç­‰å¾…å®Œæˆ
            return {
                prompt: 'Outfit Change V2',
                imageUrl: modelImageUrl,
                success: true,
                timestamp: startTime,
                taskId: taskId,
                result: undefined // å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œresult é€šè¿‡ callback è·å–
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`âŒ Outfit change V2 task creation failed: ${errorMessage}`);

            return {
                prompt: 'Outfit Change V2',
                imageUrl: modelImageUrl,
                success: false,
                error: errorMessage,
                timestamp: startTime
            };
        }
    }

    /**
     * æ ¹æ®çº¯æ–‡æœ¬æè¿°ç”Ÿæˆæ¨¡ç‰¹å›¾ç‰‡ï¼ˆå¼‚æ­¥æ¨¡å¼ï¼‰
     * @param prompt æè¿°æç¤ºè¯
     * @param options å¯é€‰é…ç½®ï¼ˆé£æ ¼ã€é•¿å®½æ¯”ã€æ¨¡å‹ï¼‰
     */
    async generateModelFromPrompt(
        prompt: string,
        options?: {
            style?: string;
            aspectRatio?: '9:16' | '1:1';
            model?: string;
        }
    ): Promise<ImageGenerationResult & { taskId?: string }> {
        const startTime = new Date();
        const aspectRatio = options?.aspectRatio ?? '9:16';
        const model = options?.model ?? 'google/nano-banana';
        const finalPrompt = options?.style
            ? `${prompt}\n\né£æ ¼å…³é”®è¯ï¼š${options.style}`
            : prompt;

        try {
            console.log('ğŸ§ Starting prompt-only model generation (async)...');
            console.log(`ğŸ“ Prompt preview: ${finalPrompt.substring(0, 80)}...`);
            console.log(`ğŸ¨ Style: ${options?.style || 'é»˜è®¤'}`);
            console.log(`ğŸï¸  Aspect Ratio: ${aspectRatio}`);
            console.log(`ğŸ¤– Model: ${model}`);

            const taskId = await this.createPromptOnlyTask(finalPrompt, aspectRatio, model);
            console.log(`âœ… KIE prompt-only task created: ${taskId}`);

            const metadata: KIETaskMetadata = {
                taskId,
                status: 'pending',
                prompt: finalPrompt,
                imageUrl: '',
                createdAt: startTime.toISOString(),
                updatedAt: startTime.toISOString(),
            };

            await saveKIETaskMetadata(metadata);

            return {
                prompt: finalPrompt,
                imageUrl: '',
                success: true,
                timestamp: startTime,
                taskId,
                result: undefined
            };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`âŒ Prompt-only model generation failed: ${errorMessage}`);

            return {
                prompt: finalPrompt,
                imageUrl: '',
                success: false,
                error: errorMessage,
                timestamp: startTime
            };
        }
    }

    /**
     * å¤„ç† KIE å›è°ƒè¯·æ±‚
     * ç”¨äº API è·¯ç”±å¤„ç†å›è°ƒ
     * @param callbackData KIE å›è°ƒæ•°æ®
     */
    static processCallback(callbackData: KIECallbackResponse): {
        taskId: string;
        success: boolean;
        resultUrls?: string[];
        error?: string;
    } {
        const { data } = callbackData;

        if (data.state === 'success') {
            const resultJson: KIEResultJson = JSON.parse(data.resultJson);
            return {
                taskId: data.taskId,
                success: true,
                resultUrls: resultJson.resultUrls
            };
        }

        return {
            taskId: data.taskId,
            success: false,
            error: `Task failed with state: ${data.state}`
        };
    }
}
